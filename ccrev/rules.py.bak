from __future__ import annotations

from numbers import Number
from typing import List, TYPE_CHECKING, Sequence, Type
import abc

from ccrev.charts.chart_base import ControlChart

if TYPE_CHECKING:
    from ccrev import main


class Signal:
    def __init__(self, signal_id: int, start_index: int = None, end_index: int = None):
        self.signal_id: int = signal_id
        self.start_index: int = start_index
        self.end_index: int = end_index

        self._is_positive = None

    def __len__(self):
        return self.end_index - self.start_index

    def is_continued_by(self, rule, datum) -> bool:
        """
        check if trend defined by string violations of self.rule is continued by datum at
        self.rule_checker.chart.data[data_index]
        """
        if rule.rule_number is not self.signal_id:
            return False
        else:
            return rule.is_continued(self, datum)

    def is_positive(self) -> bool:
        return self.rule.is_positive(self)

    def continue_trend(self) -> None:
        if self.end_index < len(self.rule_checker.chart.data):
            self.end_index += 1


class Rule:
    """
    used to check for data patterns (trends) specified by .check and min duration
    rule_number should be identifying
    """
    min_duration: int = None
    rule_number: int = None

    def __init__(self, rule_checker: RuleChecker):
        self.rule_checker: RuleChecker = rule_checker

    @staticmethod
    @abc.abstractmethod
    def check(nums: List[Number], stdev: Number, mean: Number) -> bool:
        """
        return true if specified pattern exists in param nums
        TODO stdev & mean should be KWARGS, not every child class uses/needs
        """
        raise NotImplementedError

    @staticmethod
    @abc.abstractmethod
    def does_continue(trend: Trend, data_index: int) -> bool:
        """
        returns true if pattern represented by trend is continued by data at data index
        """
        raise NotImplementedError

    @staticmethod
    @abc.abstractmethod
    def is_positive(trend: Trend) -> bool:
        """
        used to distinguish symmetrical trends
        (i.e. increasing trend vs. decreasing trend, run above mean vs. run below mean)

        returns true for "positive" trends

        positive/negative classification is semi-arbitrary certain trends (i.e. alternating increasing/decreasing)
        """
        return trend.rule_checker.chart.data[trend.start_index] > trend.rule_checker.chart.stats_data['mean']


class Rule1(Rule):
    """
    point past action limit
    """

    min_duration = 1
    rule_number = 1

    @staticmethod
    def check(nums: List[Number], stdev: Number, mean: Number) -> bool:
        return not (mean - 3 * stdev) < nums[0] < (mean + 3 * stdev)

    @staticmethod
    def does_continue(trend: Trend, data_index: int) -> bool:
        return False

    @staticmethod
    def is_positive(trend: Trend) -> bool:
        return Rule.is_positive(trend)


class Rule2(Rule):
    """
    run above or below the mean
    """
    min_duration = 8
    rule_number = 2

    @staticmethod
    def check(nums: List[Number], stdev: Number, mean: Number) -> bool:
        return all(m > mean for m in nums) or all(m < mean for m in nums)

    @staticmethod
    def does_continue(trend: Trend, data_index: int) -> bool:
        if trend.is_positive():
            return trend.rule_checker.chart.data[data_index] > trend.rule_checker.chart.stats_data['mean']
        else:
            return trend.rule_checker.chart.data[data_index] < trend.rule_checker.chart.stats_data['mean']

    @staticmethod
    def is_positive(trend: Trend) -> bool:
        return Rule.is_positive(trend)


class Rule3(Rule):
    """
    increasing or decreasing trend

    positive trend is increasing
    """
    min_duration = 6
    rule_number = 3

    @staticmethod
    def check(nums: List[Number], stdev: Number, mean: Number, comparator=None) -> bool:
        return all(a < b for a, b in zip(nums, nums[1:])) \
                   or all(a > b for a, b in zip(nums, nums[1:]))

    @staticmethod
    def does_continue(trend: Trend, data_index: int) -> bool:
        if trend.is_positive():
            return trend.rule_checker.chart.data[data_index] > trend.rule_checker.chart.data[data_index - 1]
        else:
            return trend.rule_checker.chart.data[data_index] < trend.rule_checker.chart.data[data_index - 1]

    @staticmethod
    def is_positive(trend: Trend) -> bool:
        return trend.rule_checker.chart.data[trend.start_index] < \
               trend.rule_checker.chart.data[trend.start_index + 1]


class Rule4(Rule):
    """
    excessive oscillation

    positive trends start increasing->decreasing
    """
    min_duration = 14
    rule_number = 4

    @staticmethod
    def check(nums: List[Number], stdev: Number, mean: Number, comparator=None) -> bool:
        return all(((a > b) - (a < b)) * ((b > c) - (b < c)) == -1 for a, b, c in zip(nums, nums[1:], nums[2:]))

    @staticmethod
    def does_continue(trend: Trend, data_index: int) -> bool:
        if trend.is_positive() and len(trend) % 2 is 0:  # check if trend length is even with len(trend) % 2 is 0
            return trend.rule_checker.chart.data[data_index - 1] > trend.rule_checker.chart.data[data_index]
        elif trend.is_positive() and not len(trend) % 2 is 0:
            return trend.rule_checker.chart.data[data_index - 1] < trend.rule_checker.chart.data[data_index]
        elif not trend.is_positive() and len(trend) % 2 is 0:
            return trend.rule_checker.chart.data[data_index - 1] < trend.rule_checker.chart.data[data_index]
        elif trend.is_positive() and not len(trend) % 2 is 0:
            return trend.rule_checker.chart.data[data_index - 1] > trend.rule_checker.chart.data[data_index]

    @staticmethod
    def is_positive(trend: Trend) -> bool:
        return trend.rule_checker.chart.data[trend.start_index] < \
               trend.rule_checker.chart.data[trend.start_index + 1]


# class RuleChecker:
#     def __init__(self, parent: main.ChartData = None):
#         self.chart: main.ChartData = parent
#         self.trend: Trend = None
#
#     def check(self, rule: Rule, data_index: int):
#         """
#         driver for rule-checking routine
#         """
#
#         if self.chart.signals[data_index].rule_number:
#             if self.trend:
#                 self.update_chart()
#                 self.clear_trend()
#             return  # skip points with found signals
#
#         if self.trend:  # if there's a trend
#             if self.trend.is_continued_by(data_index):
#                 self.trend.continue_trend()  # continue trend if possible
#             else:
#                 self.update_chart()  # otherwise update chart with signals represented by trend
#                 self.clear_trend()   # then clear trend to start again
#
#         # if there's no trend check if a new trend is detected at the given index
#         if not self.trend and self.is_new_trend(rule, data_index):
#             self.new_trend(rule, data_index)  # start a new trend if new trend detected
#         else:
#             pass  # otherwise go to next point
#
#     def is_new_trend(self, rule: Rule, data_index: int) -> bool:
#         """
#         check if self.chart.data[data_index] is the start of a sequence which breaks rule passed as parameter
#         """
#         if len(self.chart.data[data_index:data_index + rule.min_duration]) is not rule.min_duration or \
#                 any(signal.rule_number for signal in self.chart.signals[data_index:data_index + rule.min_duration]):
#             return False  # don't start a new trend if minimum duration criteria for that trend isn't met
#         else:
#             return rule.check(
#                 self.chart.data[data_index:data_index + rule.min_duration],
#                 self.chart.stats_data['stdev'],
#                 self.chart.stats_data['mean'],
#             )
#
#     def new_trend(self, rule: Rule, start_index) -> None:
#         self.trend = Trend(self, rule, start_index)
#         pass
#
#     def clear_trend(self) -> None:
#         self.trend = None
#
#     def update_chart(self) -> None:
#         self.chart.update_signals(self.trend)
#
#     def check_all_rules(self):
#         ...


class RuleChecker:
    def __init__(self, rules=(Rule1, Rule2, Rule3, Rule4)):
        self.trend: Trend = None
        self.rules = rules
        self._signals: List[Signal] = None

    def check(self, rule: Rule, data: List[float]) -> List[Signal]:
        """
        driver for rule-checking routine
        """

        if self.chart.signals[data_index].rule_number:
            if self.trend:
                self.update_signals()
                self.clear_trend()
            return  # skip points with found signals

        if self.trend:  # if there's a trend
            if self.trend.is_continued(data_index):
                self.trend.continue_trend()  # continue trend if possible
            else:
                self.update_signals()  # otherwise update chart with signals represented by trend
                self.clear_trend()  # then clear trend to start again

        # if there's no trend check if a new trend is detected at the given index
        if not self.trend and self.is_new_trend(rule, data_index):
            self.new_trend(rule, data_index)  # start a new trend if new trend detected
        else:
            pass  # otherwise go to next point

    def is_new_trend(self, rule: Rule, data_index: int) -> bool:
        """
        check if self.chart.data[data_index] is the start of a sequence which breaks rule passed as parameter
        """
        if len(self.chart.data[data_index:data_index + rule.min_duration]) is not rule.min_duration or \
                any(signal.rule_number for signal in self.chart.signals[data_index:data_index + rule.min_duration]):
            return False  # don't start a new trend if minimum duration criteria for that trend isn't met
        else:
            return rule.check(
                self.chart.data[data_index:data_index + rule.min_duration],
                self.chart.stats_data['stdev'],
                self.chart.stats_data['mean'],
            )

    def new_trend(self, rule: Rule, start_index) -> None:
        self.trend = Trend(self, rule, start_index)
        pass

    def clear_trend(self) -> None:
        self.trend = None

    def update_signals(self) -> None:
        self.chart.update_signals(self.trend)

    def check_all_rules(self, data) -> List[Signal]:
        signals = []
        for rule in self.rules:
            signals.append(self.check(rule, data))
        signals = self._flatten_signals(signals)
        return signals

    @staticmethod
    def _flatten_signals(signals: List[List[Signal]]) -> List[Signal]:
        flattened_signals = []
        rules_in_signalset = len(signals)
        for signalset in signals



    @staticmethod
    def signal_list_to_dict(signals):
        ...
